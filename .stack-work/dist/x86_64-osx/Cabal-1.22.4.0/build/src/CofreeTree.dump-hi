
==================== FINAL INTERFACE ====================
2015-11-03 20:02:50.38303 UTC

interface lamc_5eVrUU1K4dW8f168hbG4XR:CofreeTree 7102
  interface hash: 9746d139c9639c61b8651828f57a9ffa
  ABI hash: bce01e372bc8bbfc8df66ff866273871
  export-list hash: 1bb327c1892edca51825a888cd16fcdb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8ebd6fc67c0b23b062fbd51d8b2bef56
  sig of: Nothing
  used TH splices: False
  where
exports:
  CofreeTree.app
  CofreeTree.cf2tree
  CofreeTree.lam
  CofreeTree.num
  CofreeTree.showMe
  CofreeTree.var
  CofreeTree.AST{CofreeTree.AApply CofreeTree.AIdent CofreeTree.ALambda CofreeTree.ANumber CofreeTree.AString}
  CofreeTree.CfTree
  CofreeTree.Mu{CofreeTree.Mu}
  CofreeTree.MuTree
module dependencies:
package dependencies: StateVar-1.1.0.1@State_6K4a3UqSdqh6lGAm1wlr9s
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0*
                      base-orphans-0.4.4@baseo_E55c3OEBLyu45sND7mOuE9
                      bifunctors-5@bifun_6cWzSBWZD9ID5wcfOFIydn
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      comonad-4.2.7.2@comon_EsayKmuIGPJJdbMoBEcxRq
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN*
                      contravariant-1.3.3@contr_1HGRfJ7yos72LK91k3YDgI
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      distributive-0.4.4@distr_IiTFZxvjHzA0FvKz3AU35Q
                      free-4.12.1@free_2EJeoNML59VIyuzJGfHGjD ghc-prim-0.4.0.0
                      hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy integer-gmp-1.0.0.0
                      prelude-extras-0.4.0.2@prelu_57eavILAbKD5CaKv31zEDY
                      semigroups-0.16.2.2@semig_509rjK42Yeb8JAwFst5KmO
                      semigroupoids-5.0.0.4@semig_IPk36dXHATB4yo2y5KnSeX
                      stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr
                      tagged-0.8.1@tagge_6Tf46oJAk552xT73wGffBW
                      text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy:Data.Hashable.Generic
         stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr:Control.Monad.STM
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         semigroups-0.16.2.2@semig_509rjK42Yeb8JAwFst5KmO:Data.List.NonEmpty
                         semigroups-0.16.2.2@semig_509rjK42Yeb8JAwFst5KmO:Data.Semigroup
                         tagged-0.8.1@tagge_6Tf46oJAk552xT73wGffBW:Data.Tagged
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashMap.Base
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashSet
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Data.Traversable 89769555cf5e62f4edd3d085405c2caa
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  base-4.8.1.0:System.IO 29a6f3d7c8ad8a4e6200d8bbb6e70aae
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Tree f0b0db6bb0fd0409124a47f429a5b906
import  -/  free-4.12.1@free_2EJeoNML59VIyuzJGfHGjD:Control.Comonad.Cofree c75d0e75b71777ade08ee79afa8d3c55
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
4f897bd8698aae9036f597c808216a8c
  $cfoldr :: (a -> b -> b) -> b -> CofreeTree.AST a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   f :: a -> b -> b
                   z :: b
                   ds :: CofreeTree.AST a ->
                 case ds of wild {
                   CofreeTree.ALambda a1 a2 -> f a2 z
                   CofreeTree.AApply a1 a2 -> f a1 (f a2 z)
                   CofreeTree.ANumber a1 -> z
                   CofreeTree.AString a1 -> z
                   CofreeTree.AIdent a1 -> z }) -}
4f897bd8698aae9036f597c808216a8c
  $fEqAST :: GHC.Classes.Eq a => GHC.Classes.Eq (CofreeTree.AST a)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a $dEq :: GHC.Classes.Eq a.
                  @ (CofreeTree.AST a)
                  (CofreeTree.$fEqAST_$c== @ a $dEq)
                  (CofreeTree.$fEqAST_$c/= @ a $dEq) -}
4f897bd8698aae9036f597c808216a8c
  $fEqAST_$c/= ::
    GHC.Classes.Eq a =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq a
                   a1 :: CofreeTree.AST a
                   b :: CofreeTree.AST a ->
                 case CofreeTree.$fEqAST_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4f897bd8698aae9036f597c808216a8c
  $fEqAST_$c== ::
    GHC.Classes.Eq a =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   $dEq :: GHC.Classes.Eq a
                   ds :: CofreeTree.AST a
                   ds1 :: CofreeTree.AST a ->
                 case ds of wild {
                   CofreeTree.ALambda a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CofreeTree.ALambda b1 b2
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ a $dEq a2 b2 } }
                   CofreeTree.AApply a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CofreeTree.AApply b1 b2
                        -> case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ a $dEq a2 b2 } }
                   CofreeTree.ANumber a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CofreeTree.ANumber b1 -> GHC.Classes.eqInt a1 b1 }
                   CofreeTree.AString a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CofreeTree.AString b1 -> GHC.Base.eqString a1 b1 }
                   CofreeTree.AIdent a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CofreeTree.AIdent b1 -> GHC.Base.eqString a1 b1 } }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST :: Data.Foldable.Foldable CofreeTree.AST
  DFunId[0]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CofreeTree.AST
                  CofreeTree.$fFoldableAST_$cfold
                  CofreeTree.$fFoldableAST_$cfoldMap
                  CofreeTree.$cfoldr
                  CofreeTree.$fFoldableAST_$cfoldr'
                  CofreeTree.$fFoldableAST_$cfoldl
                  CofreeTree.$fFoldableAST_$cfoldl'
                  CofreeTree.$fFoldableAST_$cfoldr1
                  CofreeTree.$fFoldableAST_$cfoldl1
                  CofreeTree.$fFoldableAST_$ctoList
                  CofreeTree.$fFoldableAST_$cnull
                  CofreeTree.$fFoldableAST_$clength
                  CofreeTree.$fFoldableAST_$celem
                  CofreeTree.$fFoldableAST_$cmaximum
                  CofreeTree.$fFoldableAST_$cminimum
                  CofreeTree.$fFoldableAST_$csum
                  CofreeTree.$fFoldableAST_$cproduct -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST1 ::
    GHC.Num.Num a3 => CofreeTree.AST a3 -> Data.Monoid.Product a3
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a3
                   $dNum :: GHC.Num.Num a3
                   ds :: CofreeTree.AST a3 ->
                 case ds of wild {
                   CofreeTree.ALambda a1 a2
                   -> (GHC.Num.*
                         @ a3
                         $dNum
                         (GHC.Num.fromInteger @ a3 $dNum Data.Monoid.$fMonoidProduct1)
                         a2)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Product[0] <a3>_R))
                   CofreeTree.AApply a1 a2
                   -> (GHC.Num.* @ a3 $dNum a1 a2)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Product[0] <a3>_R))
                   CofreeTree.ANumber a1
                   -> (Data.Monoid.$fMonoidProduct2 @ a3 $dNum)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Product[0] <a3>_R))
                   CofreeTree.AString a1
                   -> (Data.Monoid.$fMonoidProduct2 @ a3 $dNum)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Product[0] <a3>_R))
                   CofreeTree.AIdent a1
                   -> (Data.Monoid.$fMonoidProduct2 @ a3 $dNum)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Product[0] <a3>_R)) }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST2 ::
    GHC.Num.Num a3 => CofreeTree.AST a3 -> Data.Monoid.Sum a3
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a3
                   $dNum :: GHC.Num.Num a3
                   ds :: CofreeTree.AST a3 ->
                 case ds of wild {
                   CofreeTree.ALambda a1 a2
                   -> (GHC.Num.+
                         @ a3
                         $dNum
                         (GHC.Num.fromInteger @ a3 $dNum Data.Monoid.$fMonoidSum1)
                         a2)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Sum[0] <a3>_R))
                   CofreeTree.AApply a1 a2
                   -> (GHC.Num.+ @ a3 $dNum a1 a2)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Sum[0] <a3>_R))
                   CofreeTree.ANumber a1
                   -> (Data.Monoid.$fMonoidSum2 @ a3 $dNum)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Sum[0] <a3>_R))
                   CofreeTree.AString a1
                   -> (Data.Monoid.$fMonoidSum2 @ a3 $dNum)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Sum[0] <a3>_R))
                   CofreeTree.AIdent a1
                   -> (Data.Monoid.$fMonoidSum2 @ a3 $dNum)
                        `cast`
                      (Sym (Data.Monoid.NTCo:Sum[0] <a3>_R)) }) -}
fba6845d28a67bb62420df220705f266
  $fFoldableAST3 :: a3
  {- Strictness: b -}
1d352a97d0ff2425c959a5f7f4b7df02
  $fFoldableAST4 :: a3
  {- Strictness: b -}
38cc8fd6462a4051f8f9b371025227b1
  $fFoldableAST5 :: a3
  {- Strictness: b -}
a3746cb8d7e46887421ed77106d68476
  $fFoldableAST6 :: a3
  {- Strictness: b -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$celem ::
    GHC.Classes.Eq a => a -> CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a3 $dEq :: GHC.Classes.Eq a3 eta :: a3 ->
                 let {
                   a :: a3 -> GHC.Types.Bool = GHC.Classes.== @ a3 $dEq eta
                 } in
                 (\ ds :: CofreeTree.AST a3 ->
                  case ds of wild {
                    CofreeTree.ALambda a1 a2
                    -> (a a2) `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                    CofreeTree.AApply a1 a2
                    -> case a a1 of wild1 {
                         GHC.Types.False -> (a a2) `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                         GHC.Types.True
                         -> GHC.Types.True `cast` (Sym (Data.Monoid.NTCo:Any[0])) }
                    CofreeTree.ANumber a1
                    -> GHC.Types.False `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                    CofreeTree.AString a1
                    -> GHC.Types.False `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                    CofreeTree.AIdent a1
                    -> GHC.Types.False `cast` (Sym (Data.Monoid.NTCo:Any[0])) })
                   `cast`
                 (<CofreeTree.AST a3>_R ->_R Data.Monoid.NTCo:Any[0])) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cfold :: GHC.Base.Monoid m => CofreeTree.AST m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m $dMonoid :: GHC.Base.Monoid m eta :: CofreeTree.AST m ->
                 CofreeTree.$fFoldableAST_$cfoldMap
                   @ m
                   @ m
                   $dMonoid
                   (GHC.Base.id @ m)
                   eta) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> CofreeTree.AST a -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U(1*U,1*C1(C1(U)),A)><L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ m
                   $dMonoid :: GHC.Base.Monoid m
                   f :: a -> m
                   ds :: CofreeTree.AST a ->
                 case ds of wild {
                   CofreeTree.ALambda a1 a2
                   -> GHC.Base.mappend
                        @ m
                        $dMonoid
                        (GHC.Base.mempty @ m $dMonoid)
                        (f a2)
                   CofreeTree.AApply a1 a2
                   -> GHC.Base.mappend @ m $dMonoid (f a1) (f a2)
                   CofreeTree.ANumber a1 -> GHC.Base.mempty @ m $dMonoid
                   CofreeTree.AString a1 -> GHC.Base.mempty @ m $dMonoid
                   CofreeTree.AIdent a1 -> GHC.Base.mempty @ m $dMonoid }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cfoldl ::
    (b -> a -> b) -> b -> CofreeTree.AST a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a3
                   f :: b -> a3 -> b
                   z :: b
                   t1 :: CofreeTree.AST a3 ->
                 case t1 of wild {
                   CofreeTree.ALambda a1 a2 -> f z a2
                   CofreeTree.AApply a1 a2 -> f (f z a1) a2
                   CofreeTree.ANumber a1 -> z
                   CofreeTree.AString a1 -> z
                   CofreeTree.AIdent a1 -> z }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cfoldl' ::
    (b -> a -> b) -> b -> CofreeTree.AST a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a3
                   f :: b -> a3 -> b
                   z0 :: b
                   xs :: CofreeTree.AST a3 ->
                 case xs of wild {
                   CofreeTree.ALambda a1 a2 -> f z0 a2
                   CofreeTree.AApply a1 a2
                   -> case f z0 a1 of vx { DEFAULT -> f vx a2 }
                   CofreeTree.ANumber a1 -> z0
                   CofreeTree.AString a1 -> z0
                   CofreeTree.AIdent a1 -> z0 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cfoldl1 :: (a -> a -> a) -> CofreeTree.AST a -> a
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ a3 f :: a3 -> a3 -> a3 xs :: CofreeTree.AST a3 ->
                 case xs of wild {
                   CofreeTree.ALambda a1 a2 -> a2
                   CofreeTree.AApply a1 a2 -> f a1 a2
                   CofreeTree.ANumber a1 -> CofreeTree.$fFoldableAST5 @ a3
                   CofreeTree.AString a1 -> CofreeTree.$fFoldableAST5 @ a3
                   CofreeTree.AIdent a1 -> CofreeTree.$fFoldableAST5 @ a3 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cfoldr' ::
    (a -> b -> b) -> b -> CofreeTree.AST a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ a3
                   @ b
                   f :: a3 -> b -> b
                   z0 :: b
                   xs :: CofreeTree.AST a3 ->
                 case xs of wild {
                   CofreeTree.ALambda a1 a2 -> f a2 z0
                   CofreeTree.AApply a1 a2
                   -> case f a2 z0 of vx { DEFAULT -> f a1 vx }
                   CofreeTree.ANumber a1 -> z0
                   CofreeTree.AString a1 -> z0
                   CofreeTree.AIdent a1 -> z0 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cfoldr1 :: (a -> a -> a) -> CofreeTree.AST a -> a
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ a3 f :: a3 -> a3 -> a3 xs :: CofreeTree.AST a3 ->
                 case xs of wild {
                   CofreeTree.ALambda a1 a2 -> a2
                   CofreeTree.AApply a1 a2 -> f a1 a2
                   CofreeTree.ANumber a1 -> CofreeTree.$fFoldableAST6 @ a3
                   CofreeTree.AString a1 -> CofreeTree.$fFoldableAST6 @ a3
                   CofreeTree.AIdent a1 -> CofreeTree.$fFoldableAST6 @ a3 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$clength :: CofreeTree.AST a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a3 xs :: CofreeTree.AST a3 ->
                 case xs of wild {
                   CofreeTree.ALambda a1 a2 -> GHC.Types.I# 1
                   CofreeTree.AApply a1 a2 -> GHC.Types.I# 2
                   CofreeTree.ANumber a1 -> CofreeTree.$fFoldableAST_z0
                   CofreeTree.AString a1 -> CofreeTree.$fFoldableAST_z0
                   CofreeTree.AIdent a1 -> CofreeTree.$fFoldableAST_z0 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cmaximum ::
    GHC.Classes.Ord a => CofreeTree.AST a -> a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: (\ @ a3
                   $dOrd :: GHC.Classes.Ord a3
                   eta :: CofreeTree.AST a3 ->
                 case eta of wild {
                   CofreeTree.ALambda a1 a2 -> a2
                   CofreeTree.AApply a1 a2
                   -> case GHC.Classes.>= @ a3 $dOrd a1 a2 of wild2 {
                        GHC.Types.False -> a2 GHC.Types.True -> a1 }
                   CofreeTree.ANumber a1 -> CofreeTree.$fFoldableAST4 @ a3
                   CofreeTree.AString a1 -> CofreeTree.$fFoldableAST4 @ a3
                   CofreeTree.AIdent a1 -> CofreeTree.$fFoldableAST4 @ a3 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cminimum ::
    GHC.Classes.Ord a => CofreeTree.AST a -> a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a3
                   $dOrd :: GHC.Classes.Ord a3
                   eta :: CofreeTree.AST a3 ->
                 case eta of wild {
                   CofreeTree.ALambda a1 a2 -> a2
                   CofreeTree.AApply a1 a2
                   -> case GHC.Classes.<= @ a3 $dOrd a1 a2 of wild2 {
                        GHC.Types.False -> a2 GHC.Types.True -> a1 }
                   CofreeTree.ANumber a1 -> CofreeTree.$fFoldableAST3 @ a3
                   CofreeTree.AString a1 -> CofreeTree.$fFoldableAST3 @ a3
                   CofreeTree.AIdent a1 -> CofreeTree.$fFoldableAST3 @ a3 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cnull :: CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a3 ds :: CofreeTree.AST a3 ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   CofreeTree.ANumber a1 -> GHC.Types.True
                   CofreeTree.AString a1 -> GHC.Types.True
                   CofreeTree.AIdent a1 -> GHC.Types.True }) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$cproduct :: GHC.Num.Num a => CofreeTree.AST a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                CofreeTree.$fFoldableAST1
                  `cast`
                (forall a3.
                 <GHC.Num.Num a3>_R
                 ->_R <CofreeTree.AST a3>_R
                 ->_R Data.Monoid.NTCo:Product[0] <a3>_R) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$csum :: GHC.Num.Num a => CofreeTree.AST a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                CofreeTree.$fFoldableAST2
                  `cast`
                (forall a3.
                 <GHC.Num.Num a3>_R
                 ->_R <CofreeTree.AST a3>_R
                 ->_R Data.Monoid.NTCo:Sum[0] <a3>_R) -}
4f897bd8698aae9036f597c808216a8c
  $fFoldableAST_$ctoList :: CofreeTree.AST a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a3 t1 :: CofreeTree.AST a3 ->
                 GHC.Base.build
                   @ a3
                   (\ @ b c :: a3 -> b -> b[OneShot] n :: b[OneShot] ->
                    CofreeTree.$cfoldr @ a3 @ b c n t1)) -}
00f80b118036457b8682b0fdd1d1ca48
  $fFoldableAST_z0 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
4f897bd8698aae9036f597c808216a8c
  $fFunctorAST :: GHC.Base.Functor CofreeTree.AST
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CofreeTree.AST
                  CofreeTree.$fFunctorAST_$cfmap
                  CofreeTree.$fFunctorAST_$c<$ -}
4f897bd8698aae9036f597c808216a8c
  $fFunctorAST_$c<$ :: a -> CofreeTree.AST b -> CofreeTree.AST a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b eta :: a eta1 :: CofreeTree.AST b ->
                 case eta1 of wild {
                   CofreeTree.ALambda a1 a2 -> CofreeTree.ALambda @ a a1 eta
                   CofreeTree.AApply a1 a2 -> CofreeTree.AApply @ a eta eta
                   CofreeTree.ANumber a1 -> CofreeTree.ANumber @ a a1
                   CofreeTree.AString a1 -> CofreeTree.AString @ a a1
                   CofreeTree.AIdent a1 -> CofreeTree.AIdent @ a a1 }) -}
4f897bd8698aae9036f597c808216a8c
  $fFunctorAST_$cfmap ::
    (a -> b) -> CofreeTree.AST a -> CofreeTree.AST b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a @ b f :: a -> b ds :: CofreeTree.AST a ->
                 case ds of wild {
                   CofreeTree.ALambda a1 a2 -> CofreeTree.ALambda @ b a1 (f a2)
                   CofreeTree.AApply a1 a2 -> CofreeTree.AApply @ b (f a1) (f a2)
                   CofreeTree.ANumber a1 -> CofreeTree.ANumber @ b a1
                   CofreeTree.AString a1 -> CofreeTree.AString @ b a1
                   CofreeTree.AIdent a1 -> CofreeTree.AIdent @ b a1 }) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    GHC.Classes.Ord (CofreeTree.AST a)
  DFunId[1]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(A,C(C1(U)),A,A,A,A,A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      $dEq :: GHC.Classes.Eq (CofreeTree.AST a)
                      $dOrd :: GHC.Classes.Ord a.
                  @ (CofreeTree.AST a)
                  $dEq
                  (CofreeTree.$fOrdAST_$ccompare @ a $dEq $dOrd)
                  (CofreeTree.$fOrdAST_$c< @ a $dEq $dOrd)
                  (CofreeTree.$fOrdAST_$c<= @ a $dEq $dOrd)
                  (CofreeTree.$fOrdAST_$c> @ a $dEq $dOrd)
                  (CofreeTree.$fOrdAST_$c>= @ a $dEq $dOrd)
                  (CofreeTree.$fOrdAST_$cmax @ a $dEq $dOrd)
                  (CofreeTree.$fOrdAST_$cmin @ a $dEq $dOrd) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST_$c< ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq (CofreeTree.AST a)
                   $dOrd :: GHC.Classes.Ord a
                   x :: CofreeTree.AST a
                   y :: CofreeTree.AST a ->
                 case CofreeTree.$fOrdAST_$ccompare @ a $dEq $dOrd x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST_$c<= ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq (CofreeTree.AST a)
                   $dOrd :: GHC.Classes.Ord a
                   x :: CofreeTree.AST a
                   y :: CofreeTree.AST a ->
                 case CofreeTree.$fOrdAST_$ccompare @ a $dEq $dOrd x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST_$c> ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq (CofreeTree.AST a)
                   $dOrd :: GHC.Classes.Ord a
                   x :: CofreeTree.AST a
                   y :: CofreeTree.AST a ->
                 case CofreeTree.$fOrdAST_$ccompare @ a $dEq $dOrd x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST_$c>= ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq (CofreeTree.AST a)
                   $dOrd :: GHC.Classes.Ord a
                   x :: CofreeTree.AST a
                   y :: CofreeTree.AST a ->
                 case CofreeTree.$fOrdAST_$ccompare @ a $dEq $dOrd x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST_$ccompare ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   w :: GHC.Classes.Eq (CofreeTree.AST a)
                   w1 :: GHC.Classes.Ord a
                   w2 :: CofreeTree.AST a
                   w3 :: CofreeTree.AST a ->
                 CofreeTree.$w$ccompare @ a w1 w2 w3) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST_$cmax ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    CofreeTree.AST a -> CofreeTree.AST a -> CofreeTree.AST a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq (CofreeTree.AST a)
                   $dOrd :: GHC.Classes.Ord a
                   x :: CofreeTree.AST a
                   y :: CofreeTree.AST a ->
                 case CofreeTree.$fOrdAST_$ccompare @ a $dEq $dOrd x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
4f897bd8698aae9036f597c808216a8c
  $fOrdAST_$cmin ::
    (GHC.Classes.Eq (CofreeTree.AST a), GHC.Classes.Ord a) =>
    CofreeTree.AST a -> CofreeTree.AST a -> CofreeTree.AST a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq (CofreeTree.AST a)
                   $dOrd :: GHC.Classes.Ord a
                   x :: CofreeTree.AST a
                   y :: CofreeTree.AST a ->
                 case CofreeTree.$fOrdAST_$ccompare @ a $dEq $dOrd x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
4f897bd8698aae9036f597c808216a8c
  $fShowAST :: GHC.Show.Show a => GHC.Show.Show (CofreeTree.AST a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a $dShow :: GHC.Show.Show a.
                  @ (CofreeTree.AST a)
                  (CofreeTree.$fShowAST_$cshowsPrec @ a $dShow)
                  (CofreeTree.$fShowAST_$cshow @ a $dShow)
                  (CofreeTree.$fShowAST_$cshowList @ a $dShow) -}
07568c20eaabd42fb1872dd5c7f5e54b
  $fShowAST1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AIdent "#) -}
dec1379a07bc374af1057c84860c56e3
  $fShowAST2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AString "#) -}
a8126c2ff52b63f937b0f2ef5b8ed28f
  $fShowAST3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ANumber "#) -}
b3139d3abb1d0e7057046d1dd76e231b
  $fShowAST4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AApply "#) -}
6b6923f1f13c91349853d705bc4ba22a
  $fShowAST5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALambda "#) -}
2c21b092bc4784a2e2ca98aee73769a7
  $fShowAST6 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11) -}
4f897bd8698aae9036f597c808216a8c
  $fShowAST_$cshow ::
    GHC.Show.Show a => CofreeTree.AST a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dShow :: GHC.Show.Show a x :: CofreeTree.AST a ->
                 CofreeTree.$fShowAST_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4f897bd8698aae9036f597c808216a8c
  $fShowAST_$cshowList ::
    GHC.Show.Show a => [CofreeTree.AST a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dShow :: GHC.Show.Show a
                   eta :: [CofreeTree.AST a]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (CofreeTree.AST a)
                   (CofreeTree.$fShowAST_$cshowsPrec
                      @ a
                      $dShow
                      CofreeTree.$fFoldableAST_z0)
                   eta
                   eta1) -}
4f897bd8698aae9036f597c808216a8c
  $fShowAST_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> CofreeTree.AST a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   w :: GHC.Show.Show a
                   w1 :: GHC.Types.Int
                   w2 :: CofreeTree.AST a ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 CofreeTree.$w$cshowsPrec @ a w ww1 w2 }) -}
4f897bd8698aae9036f597c808216a8c
  $fTraversableAST :: Data.Traversable.Traversable CofreeTree.AST
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CofreeTree.AST
                  CofreeTree.$fFunctorAST
                  CofreeTree.$fFoldableAST
                  CofreeTree.$fTraversableAST_$ctraverse
                  CofreeTree.$fTraversableAST_$csequenceA
                  CofreeTree.$fTraversableAST_$cmapM
                  CofreeTree.$fTraversableAST_$csequence -}
4f897bd8698aae9036f597c808216a8c
  $fTraversableAST_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b) -> CofreeTree.AST a -> m (CofreeTree.AST b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),1*C1(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ b
                   $dMonad :: GHC.Base.Monad m
                   eta :: a -> m b
                   eta1 :: CofreeTree.AST a ->
                 CofreeTree.$fTraversableAST_$ctraverse
                   @ a
                   @ m
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
4f897bd8698aae9036f597c808216a8c
  $fTraversableAST_$csequence ::
    GHC.Base.Monad m => CofreeTree.AST (m a) -> m (CofreeTree.AST a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),1*C1(C1(U)),A,A),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   $dMonad :: GHC.Base.Monad m
                   eta :: CofreeTree.AST (m a) ->
                 CofreeTree.$fTraversableAST_$ctraverse
                   @ (m a)
                   @ m
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))
                   eta) -}
4f897bd8698aae9036f597c808216a8c
  $fTraversableAST_$csequenceA ::
    GHC.Base.Applicative f =>
    CofreeTree.AST (f a) -> f (CofreeTree.AST a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   $dApplicative :: GHC.Base.Applicative f
                   eta :: CofreeTree.AST (f a) ->
                 CofreeTree.$fTraversableAST_$ctraverse
                   @ (f a)
                   @ f
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))
                   eta) -}
4f897bd8698aae9036f597c808216a8c
  $fTraversableAST_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> CofreeTree.AST a -> f (CofreeTree.AST b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U(1*U(1*C1(C1(U)),A),1*C1(U),1*C1(C1(U)),A,A)><L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ (f :: * -> *)
                   @ b
                   $dApplicative :: GHC.Base.Applicative f
                   eta :: a -> f b
                   eta1 :: CofreeTree.AST a ->
                 case eta1 of wild {
                   CofreeTree.ALambda a1 a2
                   -> GHC.Base.<*>
                        @ f
                        $dApplicative
                        @ b
                        @ (CofreeTree.AST b)
                        (GHC.Base.fmap
                           @ f
                           (GHC.Base.$p1Applicative @ f $dApplicative)
                           @ GHC.Base.String
                           @ (b -> CofreeTree.AST b)
                           (CofreeTree.ALambda @ b)
                           (GHC.Base.pure @ f $dApplicative @ GHC.Base.String a1))
                        (eta a2)
                   CofreeTree.AApply a1 a2
                   -> GHC.Base.<*>
                        @ f
                        $dApplicative
                        @ b
                        @ (CofreeTree.AST b)
                        (GHC.Base.fmap
                           @ f
                           (GHC.Base.$p1Applicative @ f $dApplicative)
                           @ b
                           @ (b -> CofreeTree.AST b)
                           (CofreeTree.AApply @ b)
                           (eta a1))
                        (eta a2)
                   CofreeTree.ANumber a1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ GHC.Types.Int
                        @ (CofreeTree.AST b)
                        (CofreeTree.ANumber @ b)
                        (GHC.Base.pure @ f $dApplicative @ GHC.Types.Int a1)
                   CofreeTree.AString a1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ GHC.Base.String
                        @ (CofreeTree.AST b)
                        (CofreeTree.AString @ b)
                        (GHC.Base.pure @ f $dApplicative @ GHC.Base.String a1)
                   CofreeTree.AIdent a1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ GHC.Base.String
                        @ (CofreeTree.AST b)
                        (CofreeTree.AIdent @ b)
                        (GHC.Base.pure @ f $dApplicative @ GHC.Base.String a1) }) -}
4f897bd8698aae9036f597c808216a8c
  $w$ccompare ::
    GHC.Classes.Ord a =>
    CofreeTree.AST a -> CofreeTree.AST a -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Classes.Ord a
                   w1 :: CofreeTree.AST a
                   w2 :: CofreeTree.AST a ->
                 case w1 of wild {
                   CofreeTree.ALambda a1 a2
                   -> case w2 of wild1 {
                        DEFAULT -> GHC.Types.LT
                        CofreeTree.ALambda b1 b2
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ -> GHC.Classes.compare @ a w a2 b2
                             GHC.Types.GT -> GHC.Types.GT } }
                   CofreeTree.AApply a1 a2
                   -> case w2 of wild1 {
                        DEFAULT -> GHC.Types.LT
                        CofreeTree.ALambda ds ds1 -> GHC.Types.GT
                        CofreeTree.AApply b1 b2
                        -> case GHC.Classes.compare @ a w a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ -> GHC.Classes.compare @ a w a2 b2
                             GHC.Types.GT -> GHC.Types.GT } }
                   CofreeTree.ANumber a1
                   -> case w2 of wild1 {
                        DEFAULT -> GHC.Types.GT
                        CofreeTree.ANumber ds -> GHC.Classes.compareInt a1 ds
                        CofreeTree.AString ds -> GHC.Types.LT
                        CofreeTree.AIdent ds -> GHC.Types.LT }
                   CofreeTree.AString a1
                   -> case w2 of wild1 {
                        DEFAULT -> GHC.Types.GT
                        CofreeTree.AString b1 -> GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1
                        CofreeTree.AIdent ds -> GHC.Types.LT }
                   CofreeTree.AIdent a1
                   -> case w2 of wild1 {
                        DEFAULT -> GHC.Types.GT
                        CofreeTree.AIdent b1
                        -> GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 } }) -}
4f897bd8698aae9036f597c808216a8c
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> CofreeTree.AST a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Show.Show a
                   ww :: GHC.Prim.Int#
                   w1 :: CofreeTree.AST a ->
                 case w1 of wild {
                   CofreeTree.ALambda b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w CofreeTree.$fShowAST6 b2
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            CofreeTree.$fShowAST5
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows6
                               (GHC.Show.showLitString
                                  b1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }
                   CofreeTree.AApply b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w CofreeTree.$fShowAST6 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w CofreeTree.$fShowAST6 b2
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             CofreeTree.$fShowAST4
                             (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                CofreeTree.$fShowAST4
                                (f (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))))) }
                   CofreeTree.ANumber b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             CofreeTree.$fShowAST3
                             (case b1 of ww2 { GHC.Types.I# ww3 ->
                              case GHC.Show.$wshowSignedInt 11 ww3 x of ww4 { (#,#) ww5 ww6 ->
                              GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                CofreeTree.$fShowAST3
                                (case b1 of ww2 { GHC.Types.I# ww3 ->
                                 case GHC.Show.$wshowSignedInt
                                        11
                                        ww3
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows8
                                           x) of ww4 { (#,#) ww5 ww6 ->
                                 GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }
                   CofreeTree.AString b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             CofreeTree.$fShowAST2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                CofreeTree.$fShowAST2
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))))) }
                   CofreeTree.AIdent b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             CofreeTree.$fShowAST1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                CofreeTree.$fShowAST1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            x))))) } }) -}
ac5ca611f548d8881f8f2086bb638a0a
  $w$scf2tree ::
    GHC.Base.String
    -> CofreeTree.AST
         (Control.Comonad.Cofree.Cofree CofreeTree.AST GHC.Base.String)
    -> (# GHC.Base.String, Data.Tree.Forest GHC.Base.String #)
  {- Arity: 2, Strictness: <L,1*U><L,1*U>, Inline: [0] -}
efafb05e4ae1734a26ed4ac3d38bd171
  $wcf2tree ::
    GHC.Show.Show a =>
    a
    -> CofreeTree.AST (Control.Comonad.Cofree.Cofree CofreeTree.AST a)
    -> (# GHC.Base.String, Data.Tree.Forest GHC.Base.String #)
  {- Arity: 3, Strictness: <L,U(A,C(U),A)><L,U><L,1*U>,
     Inline: [0] -}
4f897bd8698aae9036f597c808216a8c
  data AST a
    = ALambda GHC.Base.String a
    | AApply a a
    | ANumber GHC.Types.Int
    | AString GHC.Base.String
    | AIdent GHC.Base.String
817337a48dbe486d8f867055f817a503
  type CfTree = Control.Comonad.Cofree.Cofree CofreeTree.AST
a8e50c2fae523700cb18bc18585edc9f
  type role Mu nominal
  newtype Mu (f :: * -> *) = Mu (f (CofreeTree.Mu f))
    RecFlag: Recursive
8e6ed1519f87ad6141869277be1c8a8c
  type MuTree = CofreeTree.Mu CofreeTree.AST
7d479fe9739f97dde329e94e9e1d4294
  app ::
    CofreeTree.Mu CofreeTree.AST
    -> CofreeTree.Mu CofreeTree.AST -> CofreeTree.Mu CofreeTree.AST
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                (CofreeTree.AApply @ (CofreeTree.Mu CofreeTree.AST))
                  `cast`
                (<CofreeTree.Mu CofreeTree.AST>_R
                 ->_R <CofreeTree.Mu CofreeTree.AST>_R
                 ->_R Sym (CofreeTree.NTCo:Mu[0] <CofreeTree.AST>_N)) -}
bf77fa908c8000063dcc8af4d2c5516a
  cf2tree ::
    GHC.Show.Show a =>
    CofreeTree.CfTree a -> Data.Tree.Tree GHC.Base.String
  {- Arity: 2, Strictness: <L,U(A,C(U),A)><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: GHC.Show.Show a w1 :: CofreeTree.CfTree a ->
                 case w1 of ww { Control.Comonad.Cofree.:< ww1 ww2 ->
                 case CofreeTree.$wcf2tree @ a w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Data.Tree.Node @ GHC.Base.String ww4 ww5 } }) -}
b8b5cd22481f23457eaa2f037184a173
  cf2tree_$scf2tree ::
    CofreeTree.CfTree GHC.Base.String -> Data.Tree.Tree GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: CofreeTree.CfTree GHC.Base.String ->
                 case w of ww { Control.Comonad.Cofree.:< ww1 ww2 ->
                 case CofreeTree.$w$scf2tree ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Data.Tree.Node @ GHC.Base.String ww4 ww5 } }) -}
5cd811620c296426190d7fb7f337dfd5
  lam ::
    GHC.Base.String
    -> CofreeTree.Mu CofreeTree.AST -> CofreeTree.Mu CofreeTree.AST
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m1,
     Unfolding: InlineRule (0, True, True)
                (CofreeTree.ALambda @ (CofreeTree.Mu CofreeTree.AST))
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <CofreeTree.Mu CofreeTree.AST>_R
                 ->_R Sym (CofreeTree.NTCo:Mu[0] <CofreeTree.AST>_N)) -}
c5b2b175e9d29baae5071e6c3876fdce
  num :: GHC.Types.Int -> CofreeTree.Mu CofreeTree.AST
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m3,
     Unfolding: InlineRule (0, True, True)
                (CofreeTree.ANumber @ (CofreeTree.Mu CofreeTree.AST))
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Sym (CofreeTree.NTCo:Mu[0] <CofreeTree.AST>_N)) -}
43a11bd58aa0771d3bdf9881643499c0
  showMe :: CofreeTree.CfTree GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U(1*U,1*U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                CofreeTree.showMe1
                  `cast`
                (<CofreeTree.CfTree GHC.Base.String>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
b5a535b559412390e72efa88d210cbdf
  showMe1 ::
    CofreeTree.CfTree GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U(1*U,1*U)><L,U>,
     Unfolding: (\ x :: CofreeTree.CfTree GHC.Base.String
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (case x of ww { Control.Comonad.Cofree.:< ww1 ww2 ->
                    case CofreeTree.$w$scf2tree ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                    Data.OldList.unlines
                      (GHC.Types.:
                         @ GHC.Base.String
                         ww4
                         (Data.Tree.drawTree_drawSubTrees ww5)) } })
                   GHC.Types.True
                   eta) -}
44c5b20f250be170b340f570a9b7fecd
  var :: GHC.Base.String -> CofreeTree.Mu CofreeTree.AST
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m5,
     Unfolding: InlineRule (0, True, True)
                (CofreeTree.AIdent @ (CofreeTree.Mu CofreeTree.AST))
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (CofreeTree.NTCo:Mu[0] <CofreeTree.AST>_N)) -}
instance GHC.Classes.Eq [CofreeTree.AST] = CofreeTree.$fEqAST
instance Data.Foldable.Foldable [CofreeTree.AST]
  = CofreeTree.$fFoldableAST
instance GHC.Base.Functor [CofreeTree.AST]
  = CofreeTree.$fFunctorAST
instance GHC.Classes.Ord [CofreeTree.AST] = CofreeTree.$fOrdAST
instance GHC.Show.Show [CofreeTree.AST] = CofreeTree.$fShowAST
instance Data.Traversable.Traversable [CofreeTree.AST]
  = CofreeTree.$fTraversableAST
"SPEC cf2tree @ String" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                    GHC.Base.String
  CofreeTree.cf2tree @ [GHC.Types.Char] $dShow
  = CofreeTree.cf2tree_$scf2tree
"SPEC/CofreeTree $dmtoList @ AST" [ALWAYS] forall $dFoldable :: Data.Foldable.Foldable
                                                                  CofreeTree.AST
  Data.Foldable.$dmtoList @ CofreeTree.AST $dFoldable
  = \ @ a3 t1 :: CofreeTree.AST a3 ->
    GHC.Base.build
      @ a3
      (\ @ b c :: a3 -> b -> b[OneShot] n :: b[OneShot] ->
       CofreeTree.$cfoldr @ a3 @ b c n t1)
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

